import { prisma } from '@/lib/db';

/**
 * Script to cleanup payroll test data generated by generate-payroll-test-data.ts
 * Removes all test employees, their time entries, overtime requests, leave requests, and payroll records
 * 
 * Usage: npx ts-node scripts/cleanup-payroll-test-data.ts [employeeEmail]
 * If no email is provided, it will clean up ALL test employees (emails ending with @testpayroll.com)
 */

async function cleanupPayrollTestData() {
  try {
    const args = process.argv.slice(2);
    const targetEmail = args[0];
    
    console.log('\nüßπ Starting cleanup of payroll test data...\n');
    
    // Find test employees to delete
    const whereClause = targetEmail 
      ? { email: targetEmail }
      : { email: { endsWith: '@testpayroll.com' } };
    
    const testEmployees = await prisma.employee.findMany({
      where: whereClause,
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        employeeId: true,
      }
    });
    
    if (testEmployees.length === 0) {
      console.log('‚úÖ No test employees found to cleanup.');
      return;
    }
    
    console.log(`Found ${testEmployees.length} test employee(s) to cleanup:`);
    testEmployees.forEach(emp => {
      console.log(`  - ${emp.firstName} ${emp.lastName} (${emp.email})`);
    });
    console.log('');
    
    // Get all employee IDs
    const employeeIds = testEmployees.map(emp => emp.id);
    
    // Delete in correct order due to foreign key constraints
    
    // 1. Delete payroll earnings and deductions first
    const payrolls = await prisma.payroll.findMany({
      where: { employeeId: { in: employeeIds } },
      select: { id: true }
    });
    
    const payrollIds = payrolls.map(p => p.id);
    
    if (payrollIds.length > 0) {
      const deletedEarnings = await prisma.payrollEarning.deleteMany({
        where: { payrollId: { in: payrollIds } }
      });
      console.log(`‚úì Deleted ${deletedEarnings.count} payroll earning records`);
      
      const deletedDeductions = await prisma.deduction.deleteMany({
        where: { payrollId: { in: payrollIds } }
      });
      console.log(`‚úì Deleted ${deletedDeductions.count} deduction records`);
      
      const deletedPayrolls = await prisma.payroll.deleteMany({
        where: { employeeId: { in: employeeIds } }
      });
      console.log(`‚úì Deleted ${deletedPayrolls.count} payroll records`);
    }
    
    // 2. Delete time breaks
    const timeEntries = await prisma.timeEntry.findMany({
      where: { employeeId: { in: employeeIds } },
      select: { id: true }
    });
    
    const timeEntryIds = timeEntries.map(te => te.id);
    
    if (timeEntryIds.length > 0) {
      const deletedBreaks = await prisma.timeBreak.deleteMany({
        where: { timeEntryId: { in: timeEntryIds } }
      });
      console.log(`‚úì Deleted ${deletedBreaks.count} time break records`);
    }
    
    // 3. Delete other related records
    const deletedOvertimes = await prisma.overtime.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedOvertimes.count} overtime records`);
    
    const deletedLeaveRequests = await prisma.leaveRequest.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedLeaveRequests.count} leave request records`);
    
    const deletedBenefits = await prisma.employeeBenefit.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedBenefits.count} employee benefit records`);
    
    const deletedDocuments = await prisma.employeeDocument.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedDocuments.count} employee document records`);
    
    const deletedCompensations = await prisma.compensation.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedCompensations.count} compensation records`);
    
    const deletedGovInfo = await prisma.employeeGovernmentInfo.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedGovInfo.count} government info records`);
    
    // 4. Delete time entries
    const deletedTimeEntries = await prisma.timeEntry.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedTimeEntries.count} time entry records`);
    
    // 5. Delete user accounts
    const deletedUsers = await prisma.user.deleteMany({
      where: { employeeId: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedUsers.count} user accounts`);
    
    // 6. Finally delete the employees
    const deletedEmployees = await prisma.employee.deleteMany({
      where: { id: { in: employeeIds } }
    });
    console.log(`‚úì Deleted ${deletedEmployees.count} employee records`);
    
    // 7. Check and cleanup test organization if it has no employees
    const testOrg = await prisma.organization.findFirst({
      where: { name: 'Test Payroll Organization' },
      include: { employees: { select: { id: true } } }
    });
    
    if (testOrg && testOrg.employees.length === 0) {
      await prisma.organization.delete({
        where: { id: testOrg.id }
      });
      console.log('‚úì Deleted empty test organization');
    }
    
    console.log('\n‚úÖ Cleanup completed successfully!');
    
  } catch (error) {
    console.error('‚ùå Error during cleanup:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Run the cleanup
cleanupPayrollTestData();
